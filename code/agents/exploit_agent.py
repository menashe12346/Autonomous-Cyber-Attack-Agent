from agents.base_agent import BaseAgent
import random

class ExploitAgent(BaseAgent):
    """
    Agent that attempts to exploit the target using the best known CVE.
    It selects the highest CVSS vulnerability and tests its effect.
    """

    def __init__(self, blackboard_api, replay_buffer, policy_model, state_encoder, action_encoder, command_cache, model):
        super().__init__(
            name="ExploitAgent",
            action_space=[],
            blackboard_api=blackboard_api,
            replay_buffer=replay_buffer,
            policy_model=policy_model,
            state_encoder=state_encoder,
            action_encoder=action_encoder,
            command_cache=command_cache,
            model=model
        )

    def should_run(self):
        return True

    def get_reward(self, prev_state, action, next_state):
        """
        Reward depends on whether the exploit succeeded and its impact.
        """
        prev_dict = self.state_encoder.encoded_to_state.get(str(prev_state.tolist()), {})
        next_dict = self.state_encoder.encoded_to_state.get(str(next_state.tolist()), {})

        before_shell = prev_dict.get("runtime_behavior", {}).get("shell_opened", {})
        after_shell = next_dict.get("runtime_behavior", {}).get("shell_opened", {})

        # No shell before, shell now
        if not before_shell.get("shell_type") and after_shell.get("shell_type"):
            if after_shell.get("shell_access_level") == "root":
                return 10.0
            elif after_shell.get("shell_access_level") == "user":
                return 5.0
            else:
                return 3.0
        return -1.0  # exploit failed

    def run(self):
        print("[+] ExploitAgent running...")
        state = self.blackboard_api.get_state_for_agent(self.name)
        vulnerabilities = state.get("vulnerabilities_found", [])

        if not vulnerabilities:
            print("[!] No CVEs found — skipping.")
            return

        # נבחר את הפגיעות עם הציון הכי גבוה
        best_cve = max(vulnerabilities, key=lambda v: v.get("cvss", 0))
        cve_id = best_cve["cve"]
        print(f"[ExploitAgent] Selected CVE: {cve_id} (CVSS: {best_cve.get('cvss', 0)})")

        # נזין את זה כ־action
        self.last_action = f"EXPLOIT_{cve_id}"
        self.actions_history.append(self.last_action)

        exploit_path = get_exploit_path_for_cve(cve_id)
        if exploit_path:
            success, output = run_exploit_script(exploit_path)
        else:
            print(f"[!] No exploit found for {cve_id}")
            success = False

        # נעדכן את ה־blackboard בהתאם
        if success:
            shell = {"shell_type": "bash", "shell_access_level": "root"}
        else:
            shell = {}

        state["runtime_behavior"] = {"shell_opened": shell}
        self.blackboard_api.update_state(self.name, state)

        # הצפנה של מצב, חישוב תגמול, עדכון replay buffer
        encoded_state = self.state_encoder.encode(self.last_state, self.actions_history)
        encoded_next_state = self.state_encoder.encode(state, self.actions_history)
        reward = self.get_reward(encoded_state, self.last_action, encoded_next_state)

        experience = {
            "state": encoded_state,
            "action": 0,  # אין פעולה ממשית - רק סימולציה
            "reward": reward,
            "next_state": encoded_next_state
        }
        self.replay_buffer.add_experience(**experience)

        print(f"[ExploitAgent] Exploit {'Succeeded' if success else 'Failed'} — Reward: {reward:.2f}")
