import os
import subprocess
import json
import re
from concurrent.futures import ThreadPoolExecutor, as_completed

checkpoint_interval = 1
max_threads = 4  # אפשר להעלות אם יש CPU חזק

def create_metasploit_dataset(output_path):
    if os.path.exists(output_path):
        with open(output_path, "r") as f:
            all_exploits = json.load(f)
        print(f"[✓] Loaded existing data with {len(all_exploits)} entries.")
        return # [DEBUG]
    else:
        all_exploits = []

    all_paths = set()
    def get_all_exploit_paths():
        print("[*] Fetching all Metasploit exploits...")
        result = subprocess.run(
            ["msfconsole", "-q", "-x", "show exploits; exit"],
            capture_output=True,
            text=True,
            timeout=120
        )
        lines = result.stdout.splitlines()
        for line in lines:
            parts = line.strip().split()
            if len(parts) >= 2 and parts[1].startswith("exploit/"):
                all_paths.add(parts[1])
        return sorted(all_paths)

    def extract_exploit_details(exploit_path):
        try:
            command = (
                f"use {exploit_path}; "
                f"show targets; set target 0; "
                f"show options; show payloads; info; info -j; exit"
            )
            result = subprocess.run(
                ["msfconsole", "-q", "-x", command],
                capture_output=True,
                text=True,
                timeout=90
            )
            stdout = result.stdout

            matches = re.findall(r"\{.*\}", stdout, re.DOTALL)
            data = json.loads(matches[0]) if matches else {}

            cves = []
            for ref in data.get("references", []) or []:
                cves.extend(re.findall(r"CVE-\d{4}-\d{4,7}", ref))
            cve = cves[0] if cves else None

            required_options = {}
            options_section = re.findall(r"Module options \(.*?\):(.+?)\n\n", stdout, re.DOTALL)
            if options_section:
                for line in options_section[0].splitlines():
                    parts = line.strip().split()
                    if len(parts) >= 4 and parts[2].lower() == "yes":
                        required_options[parts[0]] = parts[1] if parts[1] != "" else None

            payloads = []
            payloads_section = re.findall(r"Compatible Payloads\n=+\n(.+?)\n\n", stdout, re.DOTALL)
            if payloads_section:
                lines = payloads_section[0].splitlines()
                for line in lines:
                    line = line.strip()
                    if re.match(r"^\d+\s+payload/", line):
                        parts = line.split()
                        if len(parts) >= 2:
                            payloads.append(parts[1])

            default_payload = data.get("default_payload") or None
            if not default_payload:
                payload_hint = re.search(r"\d+\s+(payload/\S+)", stdout)
                if payload_hint:
                    default_payload = payload_hint.group(1)

            return {
                "exploit_path": exploit_path,
                "cve": cve,
                "default_payload": default_payload,
                "other_payloads": sorted(set(payloads)),
                "required_options": required_options
            }
        except Exception as e:
            print(f"[✗] Failed on {exploit_path}: {e}")
            return None

    existing_paths = {entry["exploit_path"] for entry in all_exploits}
    all_paths = get_all_exploit_paths()
    count = 0

    try:
        for i, path in enumerate(all_paths):
            if path in existing_paths:
                continue
            print(f"[🟡 {i+1}/{len(all_paths)}] Processing: {path}")
            details = extract_exploit_details(path)
            if details:
                all_exploits.append(details)
                count += 1

                print(f"[✓] Saved: {details['exploit_path']}")
                print(f"     ➤ CVE: {details['cve']}")
                print(f"     ➤ Default Payload: {details['default_payload']}")
                print(f"     ➤ Required Options: {list(details['required_options'].keys())}")

                if count % checkpoint_interval == 0:
                    with open(output_path, "w") as f:
                        json.dump(all_exploits, f, indent=2)
                    print(f"[💾] File updated ({len(all_exploits)} total exploits).")

    except KeyboardInterrupt:
        print("\n[⚠️] Interrupted! Saving progress...")
        with open(output_path, "w") as f:
            json.dump(all_exploits, f, indent=2)
        print(f"[💾] Progress saved to: {output_path}")
        return

    with open(output_path, "w") as f:
        json.dump(all_exploits, f, indent=2)
    print(f"\n[✅] Final saved to: {output_path}")