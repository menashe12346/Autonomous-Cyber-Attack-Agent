import sys
from pathlib import Path
import re
import io
import tokenize

def remove_comments_from_c_code(code: str) -> str:
    # שמירה על מחרוזות כדי שלא נמחק תגובות שבתוכן
    string_regex = r'"(?:\\.|[^"\\])*"|\'(?:\\.|[^\'\\])*\''
    comment_regex = r'//.*?$|/\*.*?\*/'

    def replacer(match):
        text = match.group(0)
        if text.startswith('"') or text.startswith("'"):
            return text  # מחרוזת – נשאיר
        else:
            return ''    # תגובה – נמחק

    # נחליף תגובות רק אם הן לא חלק ממחרוזת
    pattern = f'({string_regex})|({comment_regex})'
    return re.sub(pattern, replacer, code, flags=re.MULTILINE | re.DOTALL)



def find_program_start_line(code: str) -> int:
    lines = code.splitlines()
    num_lines = len(lines)

    # חפש את השורה הראשונה שכוללת #include/#define/#pragma
    for i, line in enumerate(lines):
        stripped = line.strip()
        if stripped.startswith("#include") or stripped.startswith("#define") or stripped.startswith("#pragma"):
            start = i

            # נלך אחורה כל עוד יש שורות שמתחילות ב־# או תגובות או ריקות
            j = start
            while j >= 0:
                line_up = lines[j].strip()

                # נבדוק אם השורה עדיין שייכת לפרה-בלוק: תגובה או #
                if (
                    line_up == '' or
                    line_up.startswith('#')
                ):
                    j -= 1
                    continue

                # ברגע שמצאנו שורה אחרת – נעצור
                break

            # אם טיפסנו כל הדרך למעלה בלי לעצור – j יהיה -1, אז נחזיר 0
            return max(j + 1, 0)

    # אם לא מצאנו בכלל התחלה
    return 0

def find_program_end_line(code: str, start_line: int) -> int:
    lines = code.splitlines()
    num_lines = len(lines)
    brace_count = 0
    main_found = False
    start_brace_found = False

    for i in range(start_line, num_lines):
        line = lines[i]

        # שלב 1 – חיפוש main
        if not main_found:
            if re.search(r'\bmain\s*\(.*?\)', line):
                main_found = True
                brace_count += line.count('{') - line.count('}')
                if brace_count == 0 and '{' in line:
                    return i  # main סגור באותה שורה
                continue

        # שלב 2 – בתוך main
        if main_found:
            brace_count += line.count('{') - line.count('}')
            if brace_count == 0:
                return i  # שורה אחרונה בתוכנית עם main

    # שלב 3 – אם אין main: חפש את בלוק הקוד הראשון ({ ... })
    for i in range(start_line, num_lines):
        line = lines[i]
        brace_count += line.count('{') - line.count('}')
        if not start_brace_found and '{' in line:
            start_brace_found = True
        if start_brace_found and brace_count == 0:
            return i + 1  # סוף בלוק קוד ראשון

    # fallback: כל הקובץ עד הסוף
    return num_lines

def find_times_of_main(code: str):
    # Find all main() function occurrences
    main_matches = list(re.finditer(r'\b(?:int|void)?\s*main\s*\([^)]*\)\s*\{', code))
    print(f"Found {len(main_matches)} main() functions")

def extract_usage_from_printf(printf_line: str) -> str:
    match = re.search(r'usage:\s*([^"\n]+)', printf_line)  # מזהה את ה-usage עד למירכאות או סוף השורה
    if match:
        return match.group(1).strip()  # מחזיר את כל מה שבין usage: ועד למירכאות או סוף השורה
    return None

def find_usage_matches(code: str):
    # Find all 'usage:' lines
    for line in code.splitlines():
        if "usage:" in line.lower():
            print(extract_usage_from_printf(line.strip()))
            return extract_usage_from_printf(line.strip())  # מחזיר את השורה הראשונה שמצאנו


    return None

def infer_argument_type(name: str) -> str:
    lowered = name.lower()

    if any(keyword in lowered for keyword in ['ip', 'host']):
        return 'ip_address'
    if 'port' in lowered:
        return 'port'
    if any(keyword in lowered for keyword in ['file', 'path', 'dir']):
        return 'file_path'
    if any(keyword in lowered for keyword in ['command', 'cmd']):
        return 'shell_command'
    if any(keyword in lowered for keyword in ['user', 'login', 'name']):
        return 'string'
    if any(keyword in lowered for keyword in ['url', 'http', 'site']):
        return 'url'

    return 'string'  # ברירת מחדל
import re

def parse_usage_line(usage_line: str):
    # הסר רווחים מיותרים
    usage_line = usage_line.strip()

    # פיצול השורה לשם התוכנית ופרמטרים
    parts = usage_line.split()
    if len(parts) < 2:
        return None

    program_name = parts[0]  # שם התוכנית (הראשון בשורה)
    args_str = " ".join(parts[1:])  # כל מה שבא אחריו (פרמטרים)

    # חיפוש עבור פרמטרים עם סוגריים חדים <> וסוגריים מרובעים []
    tokens = re.findall(r'<([^>]+)>|\[([^\]]+)\]', args_str)  # חיפוש בתוך <> או []

    arguments = []
    
    for token in tokens:
        if token[0]:  # אם הפרמטר נמצא בתוך <>
            arguments.append({
                "name": token[0],
                "required": True,
                "type": "string"
            })
        elif token[1]:  # אם הפרמטר נמצא בתוך []
            arguments.append({
                "name": token[1],
                "required": False,
                "type": "string"
            })

    return {
        "program": program_name,
        "arguments": arguments
    }


def analyze_c_file(path: Path):
    print(f"[C] Analyzing C file: {path}")
    code = path.read_text(errors="ignore")

    code = remove_comments_from_c_code(code)

    start_line=find_program_start_line(code)
    print(start_line)
    end_line=find_program_end_line(code, start_line)
    print(end_line)

    programs = split_code_into_programs(code)
    #print(f"{programs[0]} \n\n\n\n\n\n {programs[1]}")

    program = programs[1]

    main_matches = find_times_of_main(program)
    usage_matches = find_usage_matches(program)

    print(parse_usage_line(usage_matches))

def split_code_into_programs(code: str, programs=None):
    if programs is None:
        programs = []

    lines = code.splitlines()
    if not lines:
        return programs

    start_line = find_program_start_line(code)
    if start_line is None:
        return programs

    end_line = find_program_end_line(code, start_line)
    if end_line is None:
        return programs

    # חתוך את התוכנית לפי האינדקסים
    program_lines = lines[start_line:end_line + 1]
    programs.append('\n'.join(program_lines))

    # חתוך את יתרת הקוד והעבר לפונקציה הרקורסיבית
    remaining_code = '\n'.join(lines[end_line + 1:])
    return split_code_into_programs(remaining_code, programs)


def analyze_py_file(path: Path):
    print(f"[Python] מנתח קובץ Python: {path}")
    # future logic...

def analyze_unknown_file(path: Path):
    print(f"[?] סיומת לא נתמכת לקובץ: {path}")
    # יכול להציג אזהרה / דיפולט

def analyze_file(path_str: str):
    path = Path(path_str)
    if not path.exists():
        print(f"❌ הקובץ לא קיים: {path}")
        return

    ext = path.suffix.lower()
    if ext == ".c":
        analyze_c_file(path)
    elif ext == ".py":
        analyze_py_file(path)
    elif ext in [".pl", ".pm"]:
        print(f"[Perl] קבצי Perl טרם נתמכים")
    elif ext in [".sh", ".bash"]:
        print(f"[Shell] קבצי Shell טרם נתמכים")
    else:
        analyze_unknown_file(path)

if __name__ == "__main__":
    analyze_file("/mnt/linux-data/project/code/utils/test2.c")
